#include <iostream>

using namespace std;

/*Една квадратна таблица от числа се нарича магически квадрат, когато е изпълнено следното условие:
всички суми, получени поотделно от сбора на елементите по всеки ред/всеки стълб/всеки от двата диагонала са равни.
Да се състави програма на C++, която въвежда естествени числа от интервала [1..20] в дадена квадратна таблица
и определя дали те образуват магически квадрат.
Пример:
16 3 2 13
5 10 11 8
9 6 7 12
4 15 14 1*/

int main()
{
    // създаваме квадратна матрица с размер 10 реда и 10 колони
    // не е задължително да е толкова голяма, размерът ще получаваме като вход от конзолата
    int nums_matrix[10][10];

    // създаваме променлива, която ще е размера на квадратната матрица и ще е входа на потребителя
    int size_of_matrix;
    cout << "Please enter the size of the square matrix: ";
    cin >> size_of_matrix;

    // с два цикъла, един външен, един вложен въвеждаме елементите на матрицата
    // има условие елементите да са положителни числа в диапазон от 1 до 20
    for (int row = 0; row < size_of_matrix; row++) {
        cout << "Please enter 4 positive whole numbers from 1 to 20: ";
        for (int col = 0; col < size_of_matrix; col++) {
            cin >> nums_matrix[row][col];
        }
    }

    // създаваме променлива която ще пази сумата от елементи по левия диагонал
    int left_diagonal_sum = 0;

    // създаваме променлива която ще пази сумата от елементи по десния диагонал
    int right_diagonal_sum = 0;

    // създаваме променлива която ще пази сумата от елементи по първия ред
    int row_sum = 0;

    // създаваме променлива която ще пази сумата от елементи по първата колона
    int col_sum = 0;

    // създаваме променлива която ще пази сумата от елементи на оставащите редове и колони
    int current_sum = 0;

    // с един цикъл започващ от 0 до размера на матрицата ще вземем левият диагонал
    // ляв диагонал се взима като се вземат еднакви индекси за ред и колона
    // започващи от 0 до размер на матрицата - 1
    // matrix[0][0], matrix[1][1], matrix[2][2], matrix[3][3] ... matrix[n][n]
    for (int diag = 0; diag < size_of_matrix; diag++) {
        left_diagonal_sum += nums_matrix[diag][diag];
    }

    // с два цикъла един външен, един вложен ще вземем сумата на десния диагонал
    // десен диагонал се взима като външният цикъл започва от 0 до размер на матрицата - 1
    // вложеният цикъл започва от размер на матрицата - 1 докато е по-голям или равен на 0
    // и се намалява с 1 при всяка итерация
    // във вложения цикъл първият елемент е на ред = 0 колона = размер на матрица - 1
    // след взимане на първия елемент увеличаваме стойността на външния цикъл с 1
    // по този начин взимаме следните стойнсти
    // matrix[0][3], matrix[1][2], matrix[2][1], matrix[3][0]
    for (int i = 0; i < size_of_matrix; i++) {
        for (int j = size_of_matrix - 1; j >= 0; j--) {
            right_diagonal_sum += nums_matrix[i][j];
            i++;
        }
    }

    // с два цикъла един външен и един вложен взимаме сумата от елементи на първи ред
    // външният цикъл започва от 0 докато е по малък от 1, ще се изпълни само веднъж,
    // защото ни трябва само първият ред, който е на индекс 0
    // вътрешният цикъл ще премине през всички елементи на първи ред,
    //започващ от 0 до размер на матрицата - 1 и ще се увеличава с 1 при всяка итерация
    // matrix[0][0], matrix[0][1], matrix[0][2], matrix[0][3] ... matrix[0][index + 1]
    for (int i = 0; i < 1; i++) {
        for (int j = 0; j < size_of_matrix; j++){
            row_sum += nums_matrix[i][j];
        }
    }

    // с два цикъла един външен и един вложен ще сумираме първата колона
    // външният цикъл започва от 0 до размер на матрицата - 1, увеличавайки се с 1 на всяка итерация
    // вътрешният цикъл започва от 0 докато е по малък от 1, ще се изпълни веднъж
    // взимането на първа колона става като вземем елементите на съответните индекси
    // matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0] ... matrix[index+1][0]
    for (int i = 0; i < size_of_matrix; i++) {
        for (int j = 0; j < 1; j++){
            col_sum += nums_matrix[i][j];
        }
    }

    // проверяваме ако десният диагонал е различен от левия, и от първи ред, и от първа колона
    // ако едно от условията е грешно матрицата не е магически куб
    // принтираме съобщение на конзолата и програмата приключва
    if (right_diagonal_sum != left_diagonal_sum && right_diagonal_sum != row_sum && right_diagonal_sum != col_sum) {
        cout << "The matrix is not a magical square." << endl << endl;
    } else {

        // с два цикъла един външен и един вложен ще преминем през останалите редове, започвайки от втори ред
        // тъй като вече имаме сумата на първи ред, затова външния цикъл започва от 1 до размер на матрицата - 1
        // вложеният цикъл започва от 0 до размер на матрицата - 1
        // и двата цикъла се увеличават с 1 при всяка итерация
        // във вложеният цикъл сумираме всеки елемент и го запазваме в променливата current_sum
        // след вложеният цикъл проверяваме дали current_sum е различен от row_sum първия ред
        // ако сумите са различни, принтираме съобщение на конзолата, че матрицата не е
        // магически квадрат и програмата спира
        // ако сумите са еднакви зануляваме променливата current_sum и продължаваме по останалите редове
        for (int i = 1; i < size_of_matrix; i++) {
            for (int j = 0; j < size_of_matrix; j++) {
                current_sum += nums_matrix[i][j];
            }
            if (current_sum != row_sum) {
                cout << "The matrix is not a magical square." << endl << endl;
                return 0;
            }
            current_sum = 0;
        }

        // с два цикъла един външен и един вложен ще преминем по останалите колони
        // външният цикъл започва от 1 до размер на матрицата - 1, увеличавайки се с 1 при всяка итерация
        // вложеният цикъл започва от 0 до размер на матрицата - 1, увеличавайки се с 1 при всяка итерация
        // за да вземем по един елемент от всеки ред, разменяме индексите за матрицата matrix[j][i] вместо matrix[i][j]
        // така ще вземем следните елементи matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1]
        // след като ги сумираме, извън вложения цикъл правим проверка на сумата,
        // ако текущата сума не е равна на сумата на първата колона, принтираме съобщение и програмата спира
        // МОЖЕ ДА СРАВНЯВАТЕ текуща сума (current_sum) СЪС ВСЯКА ЕДНА ОТ ПРЕДИШНИТЕ ВЗЕТИ СУМИ
        // (left_diagonal_sum, right_diagonal_sum или row_sum) след като те вече са пресметнати и проверени
        // ако сумите са равни, зануляваме current_sum и продължаваме по колоните
        for (int i = 1; i < size_of_matrix; i++){
            for (int j = 0; j < size_of_matrix; j++){
                current_sum += nums_matrix[j][i];
            }
            if (current_sum != col_sum) {
                cout << "The matrix is not a magical square." << endl << endl;
                return 0;
            }
            current_sum = 0;
        }

        // ако програмата не е спрява в някоя от проверките, значи имаме магически квадрат
        // принтираме съобщение на конзолата съдържащо магическата сума
        cout << endl;
        cout << "The matrix is a magical square, sum of each row, column and diagonal are all equal to: " << left_diagonal_sum << endl;
    }

    return 0;
}
